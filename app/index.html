<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Automata Creator</title>
    <script type="text/javascript" src="vis/dist/vis.js"></script>
    <link href="vis/dist/vis-network.min.css" rel="stylesheet" type="text/css">
    <style type="text/css">
        #mynetwork {
            width: 600px;
            height: 400px;
            border: 1px solid lightgray;
        }

        p {
            max-width: 600px;
        }
    </style>
</head>

<body onload="loadGraph()">
    <h1>Automata Creator</h1>
    <h3>Instructions:</h3>
    <ul>
        <li>Use any letter from
            <i>a</i> to
            <i>z</i> lowercase</li>
        <li>Union is identified with +</li>
        <li>To use union it needs to be inside a parenthesis
            <i>()</i> ex:
            <i>(a + b)</i>
        </li>
    </ul>
    <input type="text" name="regex" id="regex" />
    <button id="regex-button" onclick="loadRegex()">Load</button>
    <div>
        <h3>Alphabet:</h3>
        <p id="alphabet-container"></p>
    </div>
    <div id="mynetwork"></div>
    <pre id="eventSpan"></pre>
</body>
<script>
    var nodes, edges, network, alphabet;
    var statesMap = {};
    function loadRegex() {
        let reg = document.getElementById("regex").value;
        nodes.clear();
        edges.clear();
        alphabet = getAlphabet(reg);
        document.getElementById("alphabet-container").innerHTML = alphabet.join(", ");

        // Insert main node
        nodes.add({
            id: "q0",
            label: "q0"
        });
        statesMap["q0"] = {};

        // Main branch tokens
        let tokens = getTokens(reg);
        tokens.forEach(function (token) {
            var states = nodes.getIds();
            var lastState = states[states.length - 1];
            if (token[token.length - 1] != "*") {
                insertState(lastState, getNextState(), token, true);
            } else if(isFinalToken(token)){
                insertState(lastState, lastState, token, true);
            }
        });
        console.log(statesMap);
    }
    function getNextState() {
        var states = nodes.getIds();
        var lastestState = states[states.length - 1];
        return "q" + (parseInt(lastestState.slice(1)) + 1);
    }
    function getAlphabet(text) {
        tempSet = new Set(Array.from(text).filter(c => c.match(/[a-z]/i)));
        return Array.from(tempSet).sort();
    }
    function isFinalToken(token) {
        return token[0] != "(";
    }
    function getTokens(text) {
        let charArray = Array.from(text);
        let tokens = [];
        var tempParenthesisNum = 0;
        var activeToken = "";
        while (charArray.length > 0) {
            var tempChar = charArray.shift();
            if (tempChar == " ") continue;
            if (tempParenthesisNum > 0) {
                if (tempChar == "(") {
                    tempParenthesisNum++;
                } else if (tempChar == ")") {
                    tempParenthesisNum--;
                }
                activeToken += tempChar;
                if (tempParenthesisNum == 0) {
                    tokens.push(activeToken);
                    activeToken = "";
                }

            } else {
                if (tempChar != "(" && tempChar != ")") {
                    if (tempChar != "*") {
                        tokens.push(tempChar);
                    } else {
                        if (tokens.length == 0) {
                            alert("Invalid Regular Expression: can't start with *");
                            window.location.reload();
                        } else if (tokens[tokens.length - 1] != "*") {
                            tokens[tokens.length - 1] += tempChar;
                        } else {
                            alert("Invalid Regular Expression: double *");
                            window.location.reload();
                        }
                    }
                } else {
                    activeToken += tempChar;
                    tempParenthesisNum++;
                }
            }
        }
        return tokens;
    }
    function loadGraph() {
        // create an array with nodes
        /*var nodes = [
            { id: 1, label: 'Node 1' },
            { id: 2, label: 'Node 2' },
            { id: 3, label: 'Node 3:\nLeft-Aligned', font: { 'face': 'Monospace', align: 'left' } },
            { id: 4, label: 'Node 4' },
            {
                id: 5, label: 'Node 5\nLeft-Aligned box', shape: 'box',
                font: { 'face': 'Monospace', align: 'left' }
            }
        ];

        // create an array with edges
        var edges = [
            { from: 1, to: 2, label: 'middle', font: { align: 'bottom' } },
            { from: 1, to: 3, label: 'top', font: { align: 'bottom' } },
            { from: 2, to: 4, label: 'horizontal', font: { align: 'bottom' } },
            { from: 2, to: 5, label: 'bottom', font: { align: 'bottom' } }
        ];*/

        // create a network
        nodes = new vis.DataSet();
        edges = new vis.DataSet();
        insertState("q0", "q1", "E");
        var container = document.getElementById('mynetwork');
        var data = {
            nodes: nodes,
            edges: edges
        };
        var options = {
            physics: true
        };
        network = new vis.Network(container, data, options);
    }
    function insertState(from, to, label, addition = false) {
        if (!nodes.get(from)) {
            nodes.add({
                id: from,
                label: from
            });
            statesMap[from] = {
                
            }
        }
        if (!nodes.get(to)) {
            nodes.add({
                id: to,
                label: to
            });
            statesMap[to] = {

            }
        }
        if (!addition || !edges.get(from + "-" + to)) {
            edges.add({
                id: from + "-" + to,
                from: from,
                to: to,
                label: label,
                font: { align: 'top' },
                arrows: 'to'
            });
        } else {
            edges.update({
                id: from + "-" + to,
                label: edges.get(from + "-" + to).label + "," + label
            });
        }
        statesMap[from][to] = {
            reg: label,
            state: statesMap[to]
        }
        //if(network) network.redraw();
    }
</script>

</html>