<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Automata Creator</title>
    <script type="text/javascript" src="vis/dist/vis.js"></script>
    <link href="vis/dist/vis-network.min.css" rel="stylesheet" type="text/css">
    <style type="text/css">
        #mynetwork {
            width: 600px;
            height: 400px;
            border: 1px solid lightgray;
        }

        p {
            max-width: 600px;
        }
    </style>
</head>

<body onload="loadGraph()">
    <h1>Automata Creator</h1>
    <h3>Instructions:</h3>
    <ul>
        <li>Use any letter from
            <i>a</i> to
            <i>z</i> lowercase</li>
        <li>Union is identified with +</li>
        <li>To use union it needs to be inside a parenthesis
            <i>()</i> ex:
            <i>(a + b)</i>
        </li>
    </ul>
    <input type="text" name="regex" id="regex" value="a(a(ab)*)*c" />
    <button id="regex-button" onclick="loadRegex()">Load</button>
    <div>
        <h3>Alphabet:</h3>
        <p id="alphabet-container"></p>
    </div>
    <div id="mynetwork"></div>
    <pre id="eventSpan"></pre>
</body>
<script>
    var nodes, edges, network, alphabet;
    var statesMap = {};
    var edgeMap = {};
    function loadRegex() {
        let reg = document.getElementById("regex").value;
        nodes.clear();
        edges.clear();
        statesMap = {};
        edgeMap = {};

        alphabet = getAlphabet(reg);
        document.getElementById("alphabet-container").innerHTML = alphabet.join(", ");

        if (balancedBrackets(reg)) {
            // Insert main node
            nodes.add({
                id: "q0",
                label: "q0"
            });
            statesMap["q0"] = {};

            // Main branch tokens
            let tokens = getTokens(reg);
            var lastState = "q0";
            tokens.forEach(function (token) {
                var states = nodes.getIds();
                var lastState = states[states.length - 1];
                if (token[token.length - 1] != "*") {
                    var nextState = getNextState();
                    insertState(lastState, nextState, token, true);
                    lastState = nextState;
                } else {
                    insertState(lastState, lastState, token, true);
                }
            });
            analyzeEdges();
        } else {
            alert("Invalid regular expression");
        }
        console.log("Final Edge Map");
        console.log(edgeMap);
    }
    function balancedBrackets(regex) {
        counter = 0;
        let charArray = Array.from(regex);
        while (charArray.length > 0) {
            var tempChar = charArray.shift();
            if (tempChar == "(") {
                counter++;
            } else if (tempChar == ")") {
                counter--;
            }
        }
        return counter == 0;
    }
    function getNextState() {
        var states = nodes.getIds();
        var lastestState = states[states.length - 1];
        return "q" + (parseInt(lastestState.slice(1)) + 1);
    }
    function getAlphabet(text) {
        tempSet = new Set(Array.from(text).filter(c => c.match(/[a-z]/i)));
        return Array.from(tempSet).sort();
    }
    function isFinalToken(token) {
        return token[0] != "(";
    }
    function getTokens(text) {
        let charArray = Array.from(text);
        let tokens = [];
        var tempParenthesisNum = 0;
        var activeToken = "";
        while (charArray.length > 0) {
            var tempChar = charArray.shift();
            if (tempChar == " ") continue;
            if (tempParenthesisNum > 0) {
                if (tempChar == "(") {
                    tempParenthesisNum++;
                } else if (tempChar == ")") {
                    tempParenthesisNum--;
                }
                activeToken += tempChar;
                if (tempParenthesisNum == 0) {
                    tokens.push(activeToken);
                    activeToken = "";
                }

            } else {
                if (tempChar != "(" && tempChar != ")") {
                    if (tempChar != "*") {
                        tokens.push(tempChar);
                    } else {
                        if (tokens.length == 0) {
                            alert("Invalid Regular Expression: can't start with *");
                            window.location.reload();
                        } else if (tokens[tokens.length - 1] != "*") {
                            tokens[tokens.length - 1] += tempChar;
                        } else {
                            alert("Invalid Regular Expression: double *");
                            window.location.reload();
                        }
                    }
                } else {
                    activeToken += tempChar;
                    tempParenthesisNum++;
                }
            }
        }
        return tokens;
    }
    function loadGraph() {
        // create an array with nodes
        /*var nodes = [
            { id: 1, label: 'Node 1' },
            { id: 2, label: 'Node 2' },
            { id: 3, label: 'Node 3:\nLeft-Aligned', font: { 'face': 'Monospace', align: 'left' } },
            { id: 4, label: 'Node 4' },
            {
                id: 5, label: 'Node 5\nLeft-Aligned box', shape: 'box',
                font: { 'face': 'Monospace', align: 'left' }
            }
        ];

        // create an array with edges
        var edges = [
            { from: 1, to: 2, label: 'middle', font: { align: 'bottom' } },
            { from: 1, to: 3, label: 'top', font: { align: 'bottom' } },
            { from: 2, to: 4, label: 'horizontal', font: { align: 'bottom' } },
            { from: 2, to: 5, label: 'bottom', font: { align: 'bottom' } }
        ];*/

        // create a network
        nodes = new vis.DataSet();
        edges = new vis.DataSet();
        insertState("q0", "q1", "E");
        var container = document.getElementById('mynetwork');
        var data = {
            nodes: nodes,
            edges: edges
        };
        var options = {
            physics: true
        };
        network = new vis.Network(container, data, options);
    }
    function insertState(from, to, label, addition = false) {
        if (!nodes.get(from)) {
            nodes.add({
                id: from,
                label: from
            });
            statesMap[from] = {};
        }
        if (!nodes.get(to)) {
            nodes.add({
                id: to,
                label: to
            });
            statesMap[to] = {};
        }
        label = (label[label.length - 1] == "*") ? label.slice(0, label.length - 1) : label;
        if (!addition || !edges.get(from + "-" + to)) {
            edges.add({
                id: from + "-" + to,
                from: from,
                to: to,
                label: label,
                font: { align: 'top' },
                arrows: 'to'
            });
        } else {
            edges.update({
                id: from + "-" + to,
                label: edges.get(from + "-" + to).label + "," + label
            });
        }
        edgeMap[from + "-" + to] = label;
    }
    function analyzeEdges() {
        var fixArray = Object.keys(edgeMap).filter(function (key) {
            return !isFinalToken(edgeMap[key]);
        });
        fixArray.forEach(function (key) {
            var reg = edgeMap[key];
            var from = key.split("-")[0];
            var to = key.split("-")[1];

            let problemEdgeLabels = edges.get(key).label.split(",");
            var onlyOneLabel = problemEdgeLabels.length == 1;
            if (onlyOneLabel) {
                edges.remove({ id: key });
            } else {
                problemEdgeLabels.splice(problemEdgeLabels.indexOf(reg), 1);
                var newLabel = problemEdgeLabels.join(',');
                edges.update({
                    id: key,
                    label: newLabel
                });
                edgeMap[key] = newLabel;
            }

            // branch tokens
            let tokens = getTokens(reg.slice(1, reg.length - 1));
            var lastState = from;
            tokens.forEach(function (token, index) {
                var states = nodes.getIds();
                if (token[token.length - 1] != "*") {
                    var nextState = (index == tokens.length - 1) ? to : getNextState();
                    insertState(lastState, nextState, token, true);
                    lastState = nextState;
                } else {
                    insertState(lastState, lastState, token, true);
                }
            });

            if (from != lastState) {
                let nextEdges = edges.get({
                    filter: function (edge) {
                        return (edge.from == from && edge.to != lastState);
                    }
                });
                nextEdges.forEach(function (edge, index) {
                    insertState(lastState, edge.to, edge.label, true);
                });
            }
            if (onlyOneLabel) {
                delete edgeMap[key];

            }
        });
        if (fixArray.length > 0) analyzeEdges();
    }
</script>

</html>